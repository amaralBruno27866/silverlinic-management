#include "managers/ActivitiesOfDailyLivingManager.h"
#include "core/Utils.h"
#include "utils/DbLogging.h"

using namespace SilverClinic;
using namespace SilverClinic::Forms;

bool ActivitiesOfDailyLivingManager::create(const ActivitiesOfDailyLiving &form) {
    const char* sql = R"SQL(INSERT INTO activities_of_daily_living(id,case_profile_id,type,activities_data_json,created_at,modified_at)
        VALUES(?,?,?,?,?,?);)SQL";
    sqlite3_stmt* stmt=nullptr; if(sqlite3_prepare_v2(m_db,sql,-1,&stmt,nullptr)!=SQLITE_OK){ utils::logDbPrepareError("ADL create", m_db, sql); return false; } int idx=1; sqlite3_bind_int(stmt,idx++,form.getADLId()); sqlite3_bind_int(stmt,idx++,form.getCaseProfileId()); sqlite3_bind_text(stmt,idx++,form.getType().c_str(),-1,SQLITE_TRANSIENT); sqlite3_bind_text(stmt,idx++,form.getActivitiesDataJson().c_str(),-1,SQLITE_TRANSIENT); sqlite3_bind_text(stmt,idx++,form.getADLCreatedAt().toString().c_str(),-1,SQLITE_TRANSIENT); sqlite3_bind_text(stmt,idx++,form.getADLUpdatedAt().toString().c_str(),-1,SQLITE_TRANSIENT); bool ok= sqlite3_step(stmt)==SQLITE_DONE; sqlite3_finalize(stmt); return ok; }

bool ActivitiesOfDailyLivingManager::update(const ActivitiesOfDailyLiving &form) { const char* sql=R"SQL(UPDATE activities_of_daily_living SET case_profile_id=?,activities_data_json=?,modified_at=? WHERE id=?;)SQL"; sqlite3_stmt* stmt=nullptr; if(sqlite3_prepare_v2(m_db,sql,-1,&stmt,nullptr)!=SQLITE_OK){ utils::logDbPrepareError("ADL update", m_db, sql); return false; } int idx=1; sqlite3_bind_int(stmt,idx++,form.getCaseProfileId()); sqlite3_bind_text(stmt,idx++,form.getActivitiesDataJson().c_str(),-1,SQLITE_TRANSIENT); std::string now=utils::getCurrentTimestamp(); sqlite3_bind_text(stmt,idx++,now.c_str(),-1,SQLITE_TRANSIENT); sqlite3_bind_int(stmt,idx++,form.getADLId()); bool ok= sqlite3_step(stmt)==SQLITE_DONE; sqlite3_finalize(stmt); return ok; }

ActivitiesOfDailyLiving ActivitiesOfDailyLivingManager::mapRow(sqlite3_stmt* stmt) const { int id=sqlite3_column_int(stmt,0); int caseId=sqlite3_column_int(stmt,1); const char* json=reinterpret_cast<const char*>(sqlite3_column_text(stmt,3)); const char* created=reinterpret_cast<const char*>(sqlite3_column_text(stmt,4)); const char* modified=reinterpret_cast<const char*>(sqlite3_column_text(stmt,5)); return ActivitiesOfDailyLiving(id,caseId,json?json:"{}", DateTime::fromString(created?created:""), DateTime::fromString(modified?modified:"")); }

std::optional<ActivitiesOfDailyLiving> ActivitiesOfDailyLivingManager::getById(int id) const { const char* sql="SELECT * FROM activities_of_daily_living WHERE id=?"; sqlite3_stmt* stmt=nullptr; if(sqlite3_prepare_v2(m_db,sql,-1,&stmt,nullptr)!=SQLITE_OK) return std::nullopt; sqlite3_bind_int(stmt,1,id); std::optional<ActivitiesOfDailyLiving> res; if(sqlite3_step(stmt)==SQLITE_ROW) res=mapRow(stmt); sqlite3_finalize(stmt); return res; }

std::vector<ActivitiesOfDailyLiving> ActivitiesOfDailyLivingManager::listByCase(int caseProfileId) const { std::vector<ActivitiesOfDailyLiving> v; const char* sql="SELECT * FROM activities_of_daily_living WHERE case_profile_id=? ORDER BY created_at"; sqlite3_stmt* stmt=nullptr; if(sqlite3_prepare_v2(m_db,sql,-1,&stmt,nullptr)!=SQLITE_OK) return v; sqlite3_bind_int(stmt,1,caseProfileId); while(sqlite3_step(stmt)==SQLITE_ROW) v.push_back(mapRow(stmt)); sqlite3_finalize(stmt); return v; }

bool ActivitiesOfDailyLivingManager::deleteById(int id) { const char* sql="DELETE FROM activities_of_daily_living WHERE id=?"; sqlite3_stmt* stmt=nullptr; if(sqlite3_prepare_v2(m_db,sql,-1,&stmt,nullptr)!=SQLITE_OK) return false; sqlite3_bind_int(stmt,1,id); bool ok= sqlite3_step(stmt)==SQLITE_DONE; sqlite3_finalize(stmt); return ok; }

int ActivitiesOfDailyLivingManager::importFromCSV(const std::string &filePath) { int success=0, failed=0; bool inTx=false; try{ auto table=csv::CSVReader::readFile(filePath); std::vector<std::string> required={"case_profile_id","activities_data_json"}; for(const auto &h: required){ if(std::find(table.headers.begin(),table.headers.end(),h)==table.headers.end()){ utils::logStructured(utils::LogLevel::ERROR,{"MANAGER","csv_missing_header","ADL","",""},"Missing header: "+h); return 0; } } if(sqlite3_exec(m_db,"BEGIN TRANSACTION;",nullptr,nullptr,nullptr)==SQLITE_OK){ inTx=true; utils::logStructured(utils::LogLevel::DEBUG,{"MANAGER","csv_begin","ADL","",""},"BEGIN TRANSACTION"); } for(const auto &row: table.rows){ try{ int caseId=std::stoi(csv::safeGet(row,"case_profile_id")); std::string json=csv::safeGet(row,"activities_data_json"); if(json.empty()) json="{}"; std::string created=csv::safeGet(row,"created_at"); if(created.empty()) created=utils::getCurrentTimestamp(); DateTime dt=DateTime::fromString(csv::normalizeTimestampForDateTime(created)); ActivitiesOfDailyLiving form(ActivitiesOfDailyLiving::getNextId(), caseId, json, dt, dt); if(!create(form)) {failed++; utils::logStructured(utils::LogLevel::ERROR,{"MANAGER","csv_insert_fail","ADL","",""},"Insert fail");} else success++; } catch(const std::exception &e){ failed++; utils::logStructured(utils::LogLevel::ERROR,{"MANAGER","csv_row_error","ADL","",""},e.what()); } } if(inTx){ if(sqlite3_exec(m_db,"COMMIT;",nullptr,nullptr,nullptr)!=SQLITE_OK){ utils::logStructured(utils::LogLevel::ERROR,{"MANAGER","csv_commit_fail","ADL","",""},"COMMIT failed"); sqlite3_exec(m_db,"ROLLBACK;",nullptr,nullptr,nullptr);} } } catch(const std::exception &e){ if(inTx) sqlite3_exec(m_db,"ROLLBACK;",nullptr,nullptr,nullptr); utils::logStructured(utils::LogLevel::ERROR,{"MANAGER","csv_file_error","ADL","",""},e.what()); } utils::logStructured(utils::LogLevel::INFO,{"MANAGER","csv_import_summary","ADL","",""},"success="+std::to_string(success)+", failed="+std::to_string(failed)); return success; }
